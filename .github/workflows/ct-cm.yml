# .github/workflows/ct-cm.yml
name: Continuous Training and Monitoring

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '0 0 * * 0' # Runs every Sunday at 00:00 UTC (adjust as needed)

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  VM_INSTANCE_NAME: ${{ secrets.VM_INSTANCE_NAME }}
  VM_ZONE: ${{ secrets.GCP_ZONE }}
  VM_USER: ${{ secrets.VM_USER }}
  GCR_HOSTNAME: gcr.io
  IMAGE_NAME: iris-mlops-app # Ensure this matches your CI/CD image name

jobs:
  retrain-model:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run Data Preprocessing and Model Training
      run: |
        python scripts/train.py # This will call preprocess internally and train
      # Ensure data/processed and models directories are created
      working-directory: .

    - name: Read new model accuracy
      id: read_accuracy
      run: |
        NEW_ACCURACY=$(cat metrics.txt | grep accuracy | cut -d'=' -f2)
        echo "New model accuracy: $NEW_ACCURACY"
        echo "new_accuracy=$NEW_ACCURACY" >> $GITHUB_OUTPUT

    # In a real scenario, you'd compare this to a previous model's accuracy
    # and only proceed if the new model is better.
    # For this assessment, we'll assume a new model is always 'better enough' or we accept it.
    # For a more robust solution, use MLflow, DVC, or a custom model registry.

    - name: Authenticate to Google Cloud (GCR/GKE/Compute)
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Set up Google Cloud SDK
      uses: 'google-github-actions/setup-gcloud@v2'

    - name: Configure Docker to use gcloud as a credential helper
      run: gcloud auth configure-docker ${GCR_HOSTNAME}

    # This step pushes the newly trained model (if you configured train.py to save it)
    # The Dockerfile expects the model to be present at build time.
    # A more robust solution would push the model to GCS and the Flask app would load from GCS.
    # For this simplified example, we'll rebuild the Docker image with the *new* model.
    - name: Rebuild and push Docker image with new model to Google Container Registry
      run: |
        docker build -t ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.run_id }} -f app/Dockerfile .
        docker push ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.run_id }}
        docker tag ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.run_id }} ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:latest
        docker push ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:latest


  # Optional: Automatically redeploy the application if retraining was successful
  # This job triggers the deployment logic, similar to the CI/CD pipeline
  deploy-new-model:
    runs-on: ubuntu-latest
    needs: retrain-model
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $(gcloud compute instances describe ${VM_INSTANCE_NAME} --zone=${VM_ZONE} --format='value(networkInterfaces[0].accessConfigs[0].natIP)') >> ~/.ssh/known_hosts

    - name: Get VM external IP
      id: get_ip
      run: |
        VM_IP=$(gcloud compute instances describe ${VM_INSTANCE_NAME} --zone=${VM_ZONE} --format='value(networkInterfaces[0].accessConfigs[0].natIP)')
        echo "VM_IP=$VM_IP" >> $GITHUB_ENV

    - name: Authenticate to Google Cloud (GCR/GKE/Compute)
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Set up Google Cloud SDK
      uses: 'google-github-actions/setup-gcloud@v2'

    - name: Configure Docker to use gcloud as a credential helper
      run: gcloud auth configure-docker ${GCR_HOSTNAME}

    - name: Redeploy to Google Cloud VM with new model
      run: |
        echo "Redeploying image ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:latest to VM ${VM_INSTANCE_NAME} (${{ env.VM_IP}})..."
        ssh -o StrictHostKeyChecking=no ${VM_USER}@${{ env.VM_IP}} " \
          docker pull ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:latest && \
          docker stop ${IMAGE_NAME} || true && \
          docker rm ${IMAGE_NAME} || true && \
          docker run -d --restart always --name ${IMAGE_NAME} -p ${APP_PORT}:${APP_PORT} ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:latest && \
          echo 'Redeployment successful. Check http://${{ env.VM_IP }}:${APP_PORT}/'"
