# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches:
      - develop # For continuous integration during development
      - main    # For continuous deployment to production

  workflow_dispatch: # Allows manual triggering of the workflow

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCR_HOSTNAME: gcr.io
  IMAGE_NAME: iris-mlops-app # Your desired image name
  VM_INSTANCE_NAME: ${{ secrets.VM_INSTANCE_NAME }}
  VM_ZONE: ${{ secrets.GCP_ZONE }}
  VM_USER: ${{ secrets.VM_USER }}
  APP_PORT: 5000 # The port your Flask app listens on

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        # Install gunicorn and pytest-flask for the tests
        pip install gunicorn pytest-flask

    - name: Run Flake8 Linting
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=120 --statistics

    - name: Run Unit Tests (Preprocessing)
      run: pytest tests/test_preprocessing.py

    - name: Create dummy model for API tests (if not present)
      # This step is a workaround to make API tests pass in CI if the model isn't pre-trained
      # In a full pipeline, the model would be an artifact from a training stage
      run: |
        python -c "from sklearn.linear_model import LogisticRegression; import joblib; import os; \
                   dummy_model = LogisticRegression(); dummy_model.classes_ = [0,1,2]; \
                   os.makedirs('models', exist_ok=True); \
                   joblib.dump(dummy_model, 'models/iris_logistic_regression_model.joblib')"
      working-directory: .

    - name: Run Unit Tests (API)
      run: pytest tests/test_model_api.py

    - name: Authenticate to Google Cloud (GCR/GKE/Compute)
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Set up Google Cloud SDK
      uses: 'google-github-actions/setup-gcloud@v2'

    - name: Configure Docker to use gcloud as a credential helper
      run: gcloud auth configure-docker ${GCR_HOSTNAME}

    - name: Build and push Docker image to Google Container Registry
      run: |
        docker build -t ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.sha }} -f app/Dockerfile .
        docker push ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.sha }}
        docker tag ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.sha }} ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:latest
        docker push ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:latest

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test # This job depends on build-and-test succeeding
    if: github.ref == 'refs/heads/main' # Only deploy to VM from main branch pushes or manual dispatch

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $(gcloud compute instances describe ${VM_INSTANCE_NAME} --zone=${VM_ZONE} --format='value(networkInterfaces[0].accessConfigs[0].natIP)') >> ~/.ssh/known_hosts

    - name: Get VM external IP
      id: get_ip
      run: |
        VM_IP=$(gcloud compute instances describe ${VM_INSTANCE_NAME} --zone=${VM_ZONE} --format='value(networkInterfaces[0].accessConfigs[0].natIP)')
        echo "VM_IP=$VM_IP" >> $GITHUB_ENV

    - name: Deploy to Google Cloud VM
      run: |
        echo "Deploying image ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.sha }} to VM ${VM_INSTANCE_NAME} (${{ env.VM_IP}})..."
        ssh -o StrictHostKeyChecking=no ${VM_USER}@${{ env.VM_IP}} " \
          docker pull ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.sha }} && \
          docker stop ${IMAGE_NAME} || true && \
          docker rm ${IMAGE_NAME} || true && \
          docker run -d --restart always --name ${IMAGE_NAME} -p ${APP_PORT}:${APP_PORT} ${GCR_HOSTNAME}/${PROJECT_ID}/${IMAGE_NAME}:${{ github.sha }} && \
          echo 'Deployment successful. Check http://${{ env.VM_IP }}:${APP_PORT}/'"
